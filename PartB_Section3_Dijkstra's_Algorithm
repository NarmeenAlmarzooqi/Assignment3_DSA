# Compute the T statistic for `sample_1` and `sample_2`

# import the necessary libraries
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import heapq

# initialize an empty graph
G = nx.Graph()

# create a dictionary to label the nodes with their corresponding Fortnite locations
node_labels = {
    "JJ": "Junk Junction",
    "HH": "Haunted Hills",
    "PP": "Pleasant Park",
    "LL": "Loot Lake",
    "SS": "Snobby Shores",
    "TT": "Tilted Towers",
    "SF": "Shifty Shafts",
    "GG": "Greasy Grove",
    "FF": "Flush Factory",
    "LLD": "Lucky Landing",
    "FFD": "Fatal Fields",
    "SSD": "Salty Springs",
    "RR": "Retail Row",
    "LLG": "Lonely Lodge",
    "WW": "Wailing Woods",
    "RRS": "Risky Reels",
    "TTM": "Tomato Temple",
    "LLK": "Lazy Links",
    "PPM": "Paradise Palms",
}

# create a list of tuples where each tuple contains two nodes and the weight of the edge between them
edges_with_weights = [
    ("JJ", "HH", 3),
    ("HH", "PP", 3),
    ("PP", "JJ", 3),
    ("LL", "SS", 5),
    ("SS", "TT", 5),
    ("TT", "SF", 5),
    ("SF", "LL", 5),
    ("GG", "FF", 7),
    ("FF", "LLD", 7),
    ("LLD", "FFD", 8),
    ("FFD", "SSD", 7),
    ("SSD", "GG", 8),
    ("RR", "LLG", 8),
    ("LLG", "WW", 8),
    ("WW", "RRS", 8),
    ("RRS", "TTM", 8),
    ("TTM", "LLK", 8),
    ("LLK", "PPM", 8),
    ("JJ", "LL", 1),
    ("TT", "FFD", 3),
    ("PPM", "RR", 8),
    ("GG", "RR", 1),
    ("GG", "LL", 1),
    ("TTM", "FFD", 2),
    ("RRS", "LLD", 2),
    ("LLK", "FFD", 5),
    ("LLK", "SSD", 4),
    ("PPM", "SSD", 2),
    ("SF", "SSD", 2),
    ("JJ", "SSD", 6),
    ("SF", "FFD", 4),
    ("SF", "PP", 2),
    ("TT", "HH", 3),
    ("TT", "PP", 3),
    ("SS", "LLD", 4),
    ("TT", "LLD", 4),
    ("SS", "HH", 3),
    ("SS", "JJ", 4),
    ("SS", "PPM", 7),
    ("LLG", "FF", 3),
    ("LLG", "SS", 2),
    ("LLG", "JJ", 8),
    ("WW", "FF", 4),
    ("WW", "LLD", 5),
]

# add nodes and edges to the graph
for node_id, label in node_labels.items():
    G.add_node(node_id, label=label)

for start, end, weight in edges_with_weights:
    G.add_edge(start, end, weight=weight)

# Dijkstra's algorithm to find the shortest path from a single source node to all other nodes in the graph
def dijkstra(graph, start):
    # create a dictionary with all nodes setting their distances to infinity
    distances = {node: float('infinity') for node in graph.nodes}
    # set the distance from the start node to itself to 0
    distances[start] = 0

    # create a priority queue and add the start node with distance 0
    priority_queue = [(0, start)]

    while priority_queue:
        # get the node from the queue that has the smallest distance
        current_distance, current_node = heapq.heappop(priority_queue)
        
        # check the distances to all neighbors of the current node
        for neighbor, data in graph[current_node].items():
            # get the weight of the edge from current node to the neighbor
            weight = data['weight']
            # calculate the distance from the start node to this neighbor through the current node
            distance = current_distance + weight
            
            # if this distance is smaller than the previously recorded distance
            if distance < distances[neighbor]:
                # update the distance to this neighbor in the distances dictionary
                distances[neighbor] = distance
                # add this neighbor to the priority queue with the new distance
                heapq.heappush(priority_queue, (distance, neighbor))
    # return the distances dictionary with the shortest distances from the start node to all others
    return distances

# test case function
def run_dijkstra_test(graph, start_node, target_node=None):
    # run the dijkstra function to find shortest distances from start_node
    distances = dijkstra(graph, start_node)
    # if a target_node is specified, print the distance to just that node
    if target_node:
        print(f"Shortest distance from {start_node} to {target_node}: {distances[target_node]}")
    else:
        # otherwise, print all the distances from the start_node
        print(f"Shortest distances from {start_node}: {distances}")

# test cases
G = nx.Graph()
G.add_nodes_from(node_labels.keys()) # add all the nodes to the graph G
G.add_weighted_edges_from(edges_with_weights) # add all the weighted edges to the graph G

# run the test case 1 from 'JJ' to all nodes
run_dijkstra_test(G, 'JJ')

# run test case 2 for from 'JJ' to 'TT'
run_dijkstra_test(G, 'JJ', 'TT') # prints the shortest distance from 'JJ' to 'TT'
